% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert_path_to_animation_coords.R
\name{convert_path_to_animation_coords}
\alias{convert_path_to_animation_coords}
\title{Calculate Animation Coordinates from Path}
\usage{
convert_path_to_animation_coords(
  lat,
  long = NULL,
  altitude = NULL,
  extent = NULL,
  frames = 360,
  reorder = FALSE,
  reorder_first_index = 1,
  reorder_duplicate_tolerance = 0.1,
  reorder_merge_tolerance = 1,
  simplify_tolerance = 0,
  zscale = 1,
  heightmap = NULL,
  offset = 5,
  type = "bezier",
  offset_lookat = 1,
  constant_step = TRUE,
  curvature_adjust = "none",
  curvature_scale = 30,
  follow_camera = FALSE,
  follow_distance = 100,
  follow_angle = 45,
  follow_rotations = 0,
  follow_fixed = FALSE,
  follow_fixed_offset = c(10, 10, 10),
  damp_motion = FALSE,
  damp_magnitude = 0.1,
  resample_path_evenly = TRUE,
  ...
)
}
\arguments{
\item{lat}{Vector of latitudes (or other coordinate in the same coordinate reference system as extent).}

\item{long}{Vector of longitudes (or other coordinate in the same coordinate reference system as extent).}

\item{altitude}{Elevation of each point, in units of the elevation matrix (scaled by zscale).
If left \code{NULL}, this will be just the elevation value at ths surface, offset by \code{offset}. If a single value,
all data will be rendered at that altitude.}

\item{extent}{Either an object representing the spatial extent of the scene
(either from the \code{raster}, \code{terra}, \code{sf}, or \code{sp} packages),
a length-4 numeric vector specifying \code{c("xmin", "xmax","ymin","ymax")}, or the spatial object (from
the previously aforementioned packages) which will be automatically converted to an extent object.}

\item{frames}{Default \code{360}. Total number of animation frames.}

\item{reorder}{Default \code{TRUE}. If \code{TRUE}, this will attempt to re-order the rows within an \code{sf} object with
multiple paths to be one continuous, end-to-end path. This happens in two steps: merging duplicate
paths that have end points that match with another object (within \code{reorder_duplicate_tolerance} distance), and then
merges them (within \code{reorder_merge_tolerance} distance) to form a continuous path.}

\item{reorder_first_index}{Default \code{1}. The index (row) of the \code{sf} object in which to begin the reordering
process. This merges and reorders paths within \code{reorder_merge_tolerance} distance until it cannot
merge any more, and then repeats the process in the opposite direction.}

\item{reorder_duplicate_tolerance}{Default \code{0.1}. Lines that have start and end points (does not matter which)
within this tolerance that match a line already processed (order determined by \code{reorder_first_index}) will be
discarded.}

\item{reorder_merge_tolerance}{Default \code{1}. Lines that have start points that are within this distance
to a previously processed line's end point (order determined by \code{reorder_first_index}) will be reordered
within the \code{sf} object to form a continuous, end-to-end path.}

\item{simplify_tolerance}{Default \code{0} (no simplification). If greater than zero, simplifies
the path to the tolerance specified. This happens after the data has been merged if \code{reorder = TRUE}.
If the input data is specified with long-lat coordinates and \code{sf_use_s2()} returns \code{TRUE},
then the value of simplify_tolerance must be specified in meters.}

\item{zscale}{Default \code{1}. The ratio between the x and y spacing (which are assumed to be equal) and the z axis in the original heightmap.}

\item{heightmap}{Default \code{NULL}. Automatically extracted from the rgl window--only use if auto-extraction
of matrix extent isn't working. A two-dimensional matrix, where each entry in the matrix is the elevation at that point.
All points are assumed to be evenly spaced.}

\item{offset}{Default \code{5}. Offset of the track from the surface, if \code{altitude = NULL}.}

\item{type}{Default \code{cubic}. Type of transition between keyframes.
Other options are \code{linear}, \code{quad}, \code{bezier}, \code{exp}, and \code{manual}. \code{manual} just returns the values
passed in, properly formatted to be passed to \code{render_animation()}.}

\item{offset_lookat}{Default \code{0}. Amount to offset the lookat position, either along the path (if \code{constant_step = TRUE})
or towards the derivative of the Bezier curve.}

\item{constant_step}{Default \code{TRUE}. This will make the camera travel at a constant speed.}

\item{curvature_adjust}{Default \code{none}. Other options are \code{position}, \code{lookat}, and \code{both}. Whether to slow down the camera at areas of high curvature
to prevent fast swings. Only used for curve \code{type = bezier}. This does not preserve key frame positions.
Note: This feature will likely result in the \code{lookat} and \code{position} diverging if they do not
have similar curvatures at each point. This feature is best used when passing the same set of points to \code{positions} and \code{lookats}
and providing an \code{offset_lookat} value, which ensures the curvature will be the same.}

\item{curvature_scale}{Default \code{30}. Constant dividing factor for curvature. Higher values will subdivide the
path more, potentially finding a smoother path, but increasing the calculation time. Only used for curve \code{type = bezier}.
Increasing this value after a certain point will not increase the quality of the path, but it is scene-dependent.}

\item{follow_camera}{Default \code{FALSE}. If \code{TRUE}, this generates a 3rd person view that follows the path specified in \code{lat}, \code{long}, and \code{altitude}.
The distance to the camera is specified by \code{follow_distance}, and the angle (off the ground) is specified by \code{follow_angle}.
Make the camera rotate around the point as it moves by setting \code{follow_rotations} to a non-zero number. The camera points in the direction of the
You can also set the camera to be a fixed distance and angle above the by settings \code{follow_fixed = TRUE} and specifying the distance
in \code{follow_fixed_offset}.}

\item{follow_distance}{Default \code{100}. Distance for the camera to follow the point when \code{follow_camera = TRUE}.}

\item{follow_angle}{Default \code{45}.  Angle (off the ground) of the camera when \code{follow_camera = TRUE}.}

\item{follow_rotations}{Default \code{0}. Number of rotations around the point when \code{follow_camera = TRUE}.}

\item{follow_fixed}{Default \code{FALSE}. If \code{TRUE}, the camera doesn't look in the direction of the path,
but rather sits at a fixed relative location to the path.}

\item{follow_fixed_offset}{Default \code{c(10,10,10)}. If \code{follow_fixed = TRUE}, the offset from the path to place
the camera.}

\item{damp_motion}{Default \code{FALSE}. Whether the suppress quick, jerky movements of the camera by linearly interpolating
between the current camera position and the goal position. Amount of linear interpolation set in \code{damp_magnitude}.}

\item{damp_magnitude}{Default \code{0.1}. Amount of linear interpolation if \code{damp_motion = TRUE}.}

\item{resample_path_evenly}{Default \code{TRUE}. This re-samples points along the path so that the camera moves
at a constant speed along the path. This also allows paths with large numbers of points to be used with a
smaller number of frames, and improves computation time of the animation path in those instances.}

\item{...}{Other arguments to pass to \code{rayrender::generate_camera_motion()}}
}
\description{
Transforms latitude/longitude/altitude coordinates to the reference system used in \code{\link[=render_highquality]{render_highquality()}},
so they can be used to create high quality pathtraced animations by passing the output to the \code{animation_camera_coords}
argument in \code{\link[=render_highquality]{render_highquality()}}.

This function converts the path values to rayshader coordinates (by setting \code{return_coords = TRUE} in \code{\link[=render_path]{render_path()}})
and then subtracts out the rgl y-offset, which can be obtained by calling the internal function \code{rayshader:::get_scene_depth()}.
}
\examples{
#Generate a circle in Monterey Bay and fly around on top of it
\dontrun{
tmp = tempdir()

# Recreate your original example but compact, with fewer frames & smaller size.
moss_landing_coord = c(36.806807, -121.793332)
t = seq(0, 2 * pi, length.out = 360) # fewer frames for speed
circle_coords_lat = moss_landing_coord[1] + 0.25 * sin(t)
circle_coords_long = moss_landing_coord[2] + 0.25 * cos(t)

# Minimal 3D render -> frames
extent_mb = attr(montereybay, "extent")
sphere_shade(montereybay) |>
plot_3d(
	montereybay,
	zscale = 50,
	water = TRUE,
	shadowcolor = "#40310a",
	background = "tan",
	theta = 210,
	phi = 22,
	zoom = 0.40,
	fov = 55
)

render_path(
extent = extent_mb,
heightmap = montereybay,
lat = circle_coords_lat,
long = circle_coords_long,
zscale = 50,
color = "red",
antialias = TRUE,
offset = 500,
linewidth = 2
)

cam = convert_path_to_animation_coords(
extent = extent_mb,
heightmap = montereybay,
lat = circle_coords_lat,
long = circle_coords_long,
type = "bezier",
damp_motion = TRUE,
fovs = 80,
zscale = 50,
offset = 1000,
frames = length(t)
)

render_highquality(
samples = 4,
animation_camera_coords = cam,
width = 200,
height = 200,
preview = FALSE,
filename = file.path(tmp, "frame"),
use_extruded_paths = TRUE
)

# Assemble frames -> GIF (pkgdown copies from man/figures)
pngs = sprintf("\%s/frame\%d.png", tmp, seq_along(t))
av::av_encode_video(
pngs,
framerate = 24
)
}

#Now we use a "follow camera" for a third person view:
\dontrun{
follow_cam = convert_path_to_animation_coords(
extent = extent_mb,
heightmap = montereybay,
lat = circle_coords_lat,
long = circle_coords_long,
type = "bezier",
damp_motion = TRUE,
fovs = 80,
zscale = 50,
follow_camera = TRUE,
offset = 1000,
frames = length(t)
)

render_highquality(
samples = 4,
animation_camera_coords = follow_cam,
width = 200,
height = 200,
preview = FALSE,
filename = file.path(tmp, "frame"),
use_extruded_paths = TRUE
)

# See description for video (if on the documentation website)
pngs = sprintf("\%s/frame\%d.png", tmp, seq_along(t))
av::av_encode_video(
pngs,
framerate = 24
)
}
}
